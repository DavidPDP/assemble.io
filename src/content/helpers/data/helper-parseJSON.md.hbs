#### \{{parseJSON}}

The helper:

```js
parseJSON = function(data, options) {
  return options.fn(JSON.parse(data));
};
```

Templates:

Given we have a partial, `input.hbs`:

```html
<div>
  <label for="\{{id}}">\{{label}}</label>
  <input type="text" id="\{{id}}">
</div>
```

And we include our partial like this:

```html
\{{#parseJSON '{"id": "firstname", "label": "First name"}'}}
  \{{> input }}
\{{/parseJSON}}
```

The helper will parse our "inline" JSON and pass it into the partial.



Hey Jon, yes of course you are welcome to use the helper in the handlebars-helpers library. I'd be honoured!

We will use this pattern to build interface components and enforce consistency where these components are used. For example, we might build an input text component to ensure that all input text fields in the website:
- are contained inside a DIV with a classname of "input"
- have the attributes "id", "name" and "type"
- have an associated label, and the "for" attribute on the label matches the "id" attribute on the input
- optionally have a red asteriks if the field is required
- optionally have a tooltip

Instead of having to write out the same HTML over and over again, we can define it once in a partial and then include that partial inline whenever we need it. Typically Handlebars requires data to be defined separately from  templates. But in this use case it is easier to define the options for the partial where we include the partial. These options aren't "data" that should be separated from the template; they are really just options for the template.